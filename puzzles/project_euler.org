#+TITLE: Project Euler Problems
#+AUTHOR: Syed Paymaan Raza

Trying out some [[https://projecteuler.net/archives][project euler problems]] here. Mostly I do this
to learn a language. It's been a while since I coded in Python
so I thought to implement a few project euler problem solutions.
I have done a few before so hopefully this should be relatively
quick.

Used Python cheat sheets to revise concepts:
1) [[https://ehmatthes.github.io/pcc/cheatsheets/README.html][Matthes Python Cheat Sheets]]
2) [[https://github.com/ehmatthes/pcc/releases/download/v1.0.0/beginners_python_cheat_sheet_pcc_all.pdf][Matthes Python Cheat Sheets - ALL]]
3) [[https://perso.limsi.fr/pointal/_media/python:cours:mementopython3-english.pdf][Limsi Python Cheat Sheet]]
4) [[https://www.cheatography.com/davechild/cheat-sheets/python/][Dave Child Python Cheat Sheet]]

Remember, in Python, whitespace matters!

** [[https://projecteuler.net/problem%3D1][Multiples of 3 and 5]]
#+BEGIN_SRC python :results output :exports both
def is_multiple_of(num, divisor):
    return num % divisor == 0

def p1():
    sum = 0
    for i in range(0, 1000):
        if is_multiple_of(i, 3) or is_multiple_of(i, 5):
            sum += i
    return sum
         
print(p1())
#+END_SRC

#+RESULTS:
: 233168

Time complexity: O(n) where n = 1000; so really O(1) unless
we want 1000 to be variable.
Space complexity: O(1)

Another approach using list comprehensions:
#+BEGIN_SRC python :results output :exports both
def is_multiple_of(num, divisor):
    return num % divisor == 0

def p1_list_comprehensions():
    return sum(x for x in range(1000) if is_multiple_of(x, 3) or is_multiple_of(x, 5))

print(p1_list_comprehensions())
#+END_SRC

#+RESULTS:
: 233168

** [[https://projecteuler.net/problem%3D2][Even Fibonacci Numbers]]
First, let's see simple fibonacci:
#+BEGIN_SRC python :results output :exports both
""" Exp time (solve recurrence), O(n) space due to stack frames """
def fib_recursive(n):
    if n == 0:
        return 1
    if n == 1:
        return 2
    return fib_recursive(n - 1) + fib_recursive(n - 2)

""" O(n) time, O(1) space """
def fib_iterative(n):
    fib_n_minus_two = 1
    fib_n_minus_one = 2
    if n == 0:
        return fib_n_minus_two
    if n == 1:
        return fib_n_minus_one
    fib_n = -1
    for i in range(2, n + 1):
        fib_n = fib_n_minus_one + fib_n_minus_two
        fib_n_minus_two = fib_n_minus_one
        fib_n_minus_one = fib_n
    return fib_n

print(fib_recursive(4))
print(fib_iterative(4))
#+END_SRC

#+RESULTS:
: 8
: 8

Now, let's modify iterative solution to solve this problem:

#+BEGIN_SRC python :results output :exports both
def is_even(num):
    return num % 2 == 0

def p2(upper_bound):
    fib_n_minus_two = 1
    fib_n_minus_one = 2
    fib_n = -1
    sum = 2
    while (fib_n < upper_bound):
        fib_n = fib_n_minus_one + fib_n_minus_two
        fib_n_minus_two = fib_n_minus_one
        fib_n_minus_one = fib_n
        if (is_even(fib_n)):
            sum += fib_n
    return sum

print(p2(4 * (10 ** 6)))
#+END_SRC

#+RESULTS:
: 4613732

Time is O(upper_bound) but O(1) if upper_bound is constant. Space is O(1).

