In all example, we want to sort this list of numbers in ascending order:

#+BEGIN_SRC 
[3,2,87,45,43,77,12,99,34,75,23,74,105,950,450,346,210,323]
#+END_SRC

** Bubble sort
If we think visually, this is just ~bubbling~ up elements (starting from index 0) to the right. After =i= iterations, the
last =i= elements in the array are ordered. Note that in bubble sort, the maximums are bubbled to the unsorted section (right).

#+BEGIN_SRC C++ :exports both
#include <array>
#include <iostream>

namespace my {

/// @brief Swaps array[firstIndex] with array[secondIndex]
template <size_t SIZE>
void swap(std::array<int, SIZE>& array, size_t firstIndex, size_t secondIndex);

/// @brief Performs bubble sort on array
template <size_t SIZE> void bubbleSort(std::array<int, SIZE>& array);

/// @brief Prints a given array
template <size_t SIZE>
void printArrayToStdOut(const std::array<int, SIZE>& array);
}

int main() {
    using namespace my;

    std::array<int, 18> array = {3,  2,  87, 45,  43,  77,  12,  99,  34,
                                 75, 23, 74, 105, 950, 450, 346, 210, 323};

    printArrayToStdOut(array);

    bubbleSort(array);

    printArrayToStdOut(array);

    return 0;
}

template <size_t SIZE> void my::bubbleSort(std::array<int, SIZE>& array) {
    for (size_t i = 0; i < SIZE - 1; ++i) {
        for (size_t j = 0; j < SIZE - 1 - i; ++j) {
            if (array[j] > array[j + 1]) {
                swap(array, j, j + 1);
            }
        }
    }
}

template <size_t SIZE>
void my::swap(std::array<int, SIZE>& array, size_t firstIndex,
              size_t secondIndex) {
    const int firstIndexOriginalValue = array[firstIndex];
    array[firstIndex] = array[secondIndex];
    array[secondIndex] = firstIndexOriginalValue;
}

template <size_t SIZE>
void my::printArrayToStdOut(const std::array<int, SIZE>& array) {
    std::cout << "[ ";
    for (const auto& element : array) {
        std::cout << element << " ";
    }
    std::cout << "] " << std::endl;
}

#+END_SRC

#+RESULTS:
| [ | 3 | 2 | 87 | 45 | 43 | 77 | 12 | 99 | 34 | 75 | 23 | 74 | 105 | 950 | 450 | 346 | 210 | 323 | ] |
| [ | 2 | 3 | 12 | 23 | 34 | 43 | 45 | 74 | 75 | 77 | 87 | 99 | 105 | 210 | 323 | 346 | 450 | 950 | ] |

*** Analysis
In the worst case, time complexity is $O(n^2)$ where =n= is the number of elements in the array or size of the array. Average is the same. Best is actually $O(n)$ but for that we have to modify the
above algorithm to cache whether we made a swap during an iteration. If the list is already sorted, a linear scan would result in
no swaps at which point we'll end the algorithm. 
In terms of memory, this algorithm is $O(1)$.

** Insertion sort
Similar to bubble sort.
If we think visually, this is just ~bubbling~ up elements (starting from index 1) to the left. After =i= iterations, the
first =i= elements in the array are ordered. Note that in insertion sort, the minimums are bubbled to the sort section in the left.
Note that both bubble sort and insertion sort are =inplace= algorithms i.e. they modify the array while it's being sorted. At
the end, the input array /is/ is the sorted array.
#+BEGIN_SRC C++ :exports both
#include <array>
#include <iostream>

namespace my {

/// @brief Swaps array[firstIndex] with array[secondIndex]
template <size_t SIZE>
void swap(std::array<int, SIZE>& array, size_t firstIndex, size_t secondIndex);

/// @brief Performs insertion sort on array
template <size_t SIZE> void insertionSort(std::array<int, SIZE>& array);

/// @brief Prints a given array
template <size_t SIZE>
void printArrayToStdOut(const std::array<int, SIZE>& array);
}

int main() {
    using namespace my;

    std::array<int, 18> array = {3,  2,  87, 45,  43,  77,  12,  99,  34,
                                 75, 23, 74, 105, 950, 450, 346, 210, 323};

    printArrayToStdOut(array);

    insertionSort(array);

    printArrayToStdOut(array);

    return 0;
}

template <size_t SIZE> void my::insertionSort(std::array<int, SIZE>& array) {
    for (int i = 1; i <= SIZE - 1; ++i) {
        const int key = array[i];
        for (int j = i - 1; j >= 0; --j) {
            // if at any point when going left, we find an element that is
            // smaller than the
            // key, we can safely break. This is because we know that the left
            // section is sorted
            // and if an element is already smaller than the key, than we don't
            // need to go any more left.
            if (array[j] <= key) {
                break;
            }
            if (array[j] > array[j + 1]) {
                swap(array, j, j + 1);
            }
        }
    }
}

template <size_t SIZE>
void my::swap(std::array<int, SIZE>& array, size_t firstIndex,
              size_t secondIndex) {
    // another way of swapping without using temp
    // don't like this too much because of potential integer overflows :)
    array[firstIndex] = array[firstIndex] + array[secondIndex];
    array[secondIndex] = array[firstIndex] - array[secondIndex];
    array[firstIndex] = array[firstIndex] - array[secondIndex];
}

template <size_t SIZE>
void my::printArrayToStdOut(const std::array<int, SIZE>& array) {
    std::cout << "[ ";
    for (const auto& element : array) {
        std::cout << element << " ";
    }
    std::cout << "] " << std::endl;
}
#+END_SRC

#+RESULTS:
| [ | 3 | 2 | 87 | 45 | 43 | 77 | 12 | 99 | 34 | 75 | 23 | 74 | 105 | 950 | 450 | 346 | 210 | 323 | ] |
| [ | 2 | 3 | 12 | 23 | 34 | 43 | 45 | 74 | 75 | 77 | 87 | 99 | 105 | 210 | 323 | 346 | 450 | 950 | ] |

*** Analysis
This is again $O(n^2)$ in time. Average is the same. In the best case though, this will be $O(n)$. Memory is $O(1)$.
Note that we can make $O(nlogn)$ comparisons instead of $O(n^2)$ by using binary search at every iteration. Swaps are
still $O(n^2)$ though, sadly.
** Merge sort
Typical divide and conquer algorithm which can be solved recursively. The beauty of recursion is that the code
is self documenting:

#+BEGIN_SRC C++ :exports both
#include <algorithm>
#include <iostream>
#include <vector>

namespace my {

/// @brief Performs merge sort on array
std::vector<int> mergeSort(std::vector<int>& array);

/// @brief Merge two sorted arrays
std::vector<int> mergeSortedArrays(std::vector<int>& firstSortedArray,
                                   std::vector<int>& secondSortedArray);

/// @brief Prints a given array
void printArrayToStdOut(const std::vector<int>& array);
}

int main() {
    using namespace my;

    // for this example, array size has to be of the form 2^n where n a
    // non-negative integer
    std::vector<int> array = {3,  2,  87, 45, 43,  77,  12,  99,
                              34, 75, 23, 74, 105, 950, 450, 346};

    printArrayToStdOut(array);

    printArrayToStdOut(mergeSort(array));

    return 0;
}

std::vector<int> my::mergeSort(std::vector<int>& array) {
    const size_t arraySize = array.size();
    if (arraySize <= 1)
        return array;

    const bool isArraySizeEven = (arraySize % 2 == 0);
    if (!isArraySizeEven) {
        std::cout << "Only even sized arrays supported for now" << std::endl;
        return array;
    }

    std::vector<int> leftArray;
    std::vector<int> rightArray;

    for (size_t vectorIndex = 0; vectorIndex < array.size(); ++vectorIndex) {
        if (vectorIndex <= array.size() / 2 - 1) {
            leftArray.push_back(array[vectorIndex]);
        } else {
            rightArray.push_back(array[vectorIndex]);
        }
    }

    leftArray = mergeSort(leftArray);
    rightArray = mergeSort(rightArray);

    return mergeSortedArrays(leftArray, rightArray);
}

std::vector<int> my::mergeSortedArrays(std::vector<int>& firstSortedArray,
                                       std::vector<int>& secondSortedArray) {
    // no need to do anything if arrays are empty
    if (firstSortedArray.empty() && secondSortedArray.empty())
        return firstSortedArray;
    if (firstSortedArray.empty())
        return secondSortedArray;
    if (secondSortedArray.empty())
        return firstSortedArray;

    // ensure firstSortedArray is the same size as secondSortedArray
    if (firstSortedArray.size() != secondSortedArray.size()) {
        // Until I setup asserts...
        std::cout << "Arrays must be the same size" << std::endl;
        return firstSortedArray;
    }

    size_t firstSortedArrayPtrIndex = 0;
    size_t secondSortedArrayPtrIndex = 0;
    size_t mergedArrayPtrIndex = 0;

    std::vector<int> mergedArray;
    while (mergedArrayPtrIndex <= 2 * firstSortedArray.size() - 1) {
        const bool allFirstSortedArrayValuesUsed =
            firstSortedArrayPtrIndex > firstSortedArray.size() - 1;
        const bool allSecondSortedArrayValuesUsed =
            secondSortedArrayPtrIndex > secondSortedArray.size() - 1;
        const bool useFirstSortedArrayValue =
            !allFirstSortedArrayValuesUsed &&
            (allSecondSortedArrayValuesUsed ||
             (firstSortedArray[firstSortedArrayPtrIndex] <
              secondSortedArray[secondSortedArrayPtrIndex]));
        if (useFirstSortedArrayValue) {
            mergedArray.push_back(firstSortedArray[firstSortedArrayPtrIndex]);
            ++firstSortedArrayPtrIndex;
        } else {
            mergedArray.push_back(secondSortedArray[secondSortedArrayPtrIndex]);
            ++secondSortedArrayPtrIndex;
        }

        ++mergedArrayPtrIndex;
    }

    return mergedArray;
}

void my::printArrayToStdOut(const std::vector<int>& array) {
    std::cout << "[ ";
    for (const auto& element : array) {
        std::cout << element << " ";
    }
    std::cout << "] " << std::endl;
}

#+END_SRC

#+RESULTS:
| [ | 3 | 2 | 87 | 45 | 43 | 77 | 12 | 99 | 34 | 75 | 23 | 74 | 105 | 950 | 450 | 346 | ] |
| [ | 2 | 3 | 12 | 23 | 34 | 43 | 45 | 74 | 75 | 77 | 87 | 99 | 105 | 346 | 450 | 950 | ] |

*** Analysis
Best, average and worst time is sigma(nlogn). Memory in the worst case is O(n). Note that we sometimes use
sigma for best, theta for average and O for worst case complexities.

*** Note
A lot of code here is not production quality. This is just quick brainstorming to get things working. For instance,
clearly using =std::vector= as an /array/ is a bad idea because of the cost of lookups. But it gets the point across as an example.
** Quick sort
** Heap sort
** BST sort
** Counting sort
** Radix sort
