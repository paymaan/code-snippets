In all example, we want to sort this list of numbers in ascending order:

#+BEGIN_SRC 
[3,2,87,45,43,77,12,99,34,75,23,74,105,950,450,346,210,323]
#+END_SRC

** Bubble sort
If we think visually, this is just ~bubbling~ up elements (starting from index 0) to the right. After =i= iterations, the
last =i= elements in the array are ordered. Note that in bubble sort, the maximums are bubbled to the unsorted section (right).

#+BEGIN_SRC C++ :exports both
#include <array>
#include <iostream>

namespace my {

/// @brief Swaps array[firstIndex] with array[secondIndex]
template <size_t SIZE>
void swap(std::array<int, SIZE>& array, size_t firstIndex, size_t secondIndex);

/// @brief Performs bubble sort on array
template <size_t SIZE> void bubbleSort(std::array<int, SIZE>& array);

/// @brief Prints a given array
template <size_t SIZE>
void printArrayToStdOut(const std::array<int, SIZE>& array);
}

int main() {
    using namespace my;

    std::array<int, 18> array = {3,  2,  87, 45,  43,  77,  12,  99,  34,
                                 75, 23, 74, 105, 950, 450, 346, 210, 323};

    printArrayToStdOut(array);

    bubbleSort(array);

    printArrayToStdOut(array);

    return 0;
}

template <size_t SIZE> void my::bubbleSort(std::array<int, SIZE>& array) {
    for (int i = 0; i < SIZE - 1; ++i) {
        for (int j = 0; j < SIZE - 1 - i; ++j) {
            if (array[j] > array[j + 1]) {
                swap(array, j, j + 1);
            }
        }
    }
}

template <size_t SIZE>
void my::swap(std::array<int, SIZE>& array, size_t firstIndex,
              size_t secondIndex) {
    const int firstIndexOriginalValue = array[firstIndex];
    array[firstIndex] = array[secondIndex];
    array[secondIndex] = firstIndexOriginalValue;
}

template <size_t SIZE>
void my::printArrayToStdOut(const std::array<int, SIZE>& array) {
    std::cout << "[ ";
    for (const auto& element : array) {
        std::cout << element << " ";
    }
    std::cout << "] " << std::endl;
}

#+END_SRC

#+RESULTS:
| [ | 3 | 2 | 87 | 45 | 43 | 77 | 12 | 99 | 34 | 75 | 23 | 74 | 105 | 950 | 450 | 346 | 210 | 323 | ] |
| [ | 2 | 3 | 12 | 23 | 34 | 43 | 45 | 74 | 75 | 77 | 87 | 99 | 105 | 210 | 323 | 346 | 450 | 950 | ] |

*** Analysis
In the worst case, time complexity is $O(n^2)$ where =n= is the number of elements in the array or size of the array. Average is the same. Best is actually $O(n)$ but for that we have to modify the
above algorithm to cache whether we made a swap during an iteration. If the list is already sorted, a linear scan would result in
no swaps at which point we'll end the algorithm. 
In terms of memory, this algorithm is $O(1)$.

** Insertion sort
Similar to bubble sort.
If we think visually, this is just ~bubbling~ up elements (starting from index 1) to the left. After =i= iterations, the
first =i= elements in the array are ordered. Note that in insertion sort, the minimums are bubbled to the sort section in the left.
Note that both bubble sort and insertion sort are =inplace= algorithms i.e. they modify the array while it's being sorted. At
the end, the input array /is/ is the sorted array.
#+BEGIN_SRC C++ :exports both
#include <array>
#include <iostream>

namespace my {

/// @brief Swaps array[firstIndex] with array[secondIndex]
template <size_t SIZE>
void swap(std::array<int, SIZE>& array, size_t firstIndex, size_t secondIndex);

/// @brief Performs insertion sort on array
template <size_t SIZE> void insertionSort(std::array<int, SIZE>& array);

/// @brief Prints a given array
template <size_t SIZE>
void printArrayToStdOut(const std::array<int, SIZE>& array);
}

int main() {
    using namespace my;

    std::array<int, 18> array = {3,  2,  87, 45,  43,  77,  12,  99,  34,
                                 75, 23, 74, 105, 950, 450, 346, 210, 323};

    printArrayToStdOut(array);

    insertionSort(array);

    printArrayToStdOut(array);

    return 0;
}

template <size_t SIZE> void my::insertionSort(std::array<int, SIZE>& array) {
    for (int i = 1; i <= SIZE - 1; ++i) {
        const int key = array[i];
        for (int j = i - 1; j >= 0; --j) {
            // if at any point when going left, we find an element that is
            // smaller than the
            // key, we can safely break. This is because we know that the left
            // section is sorted
            // and if an element is already smaller than the key, than we don't
            // need to go any more left.
            if (array[j] <= key) {
                break;
            }
            if (array[j] > array[j + 1]) {
                swap(array, j, j + 1);
            }
        }
    }
}

template <size_t SIZE>
void my::swap(std::array<int, SIZE>& array, size_t firstIndex,
              size_t secondIndex) {
    // another way of swapping without using temp
    // don't like this too much because of potential integer overflows :)
    array[firstIndex] = array[firstIndex] + array[secondIndex];
    array[secondIndex] = array[firstIndex] - array[secondIndex];
    array[firstIndex] = array[firstIndex] - array[secondIndex];
}

template <size_t SIZE>
void my::printArrayToStdOut(const std::array<int, SIZE>& array) {
    std::cout << "[ ";
    for (const auto& element : array) {
        std::cout << element << " ";
    }
    std::cout << "] " << std::endl;
}
#+END_SRC

#+RESULTS:
| [ | 3 | 2 | 87 | 45 | 43 | 77 | 12 | 99 | 34 | 75 | 23 | 74 | 105 | 950 | 450 | 346 | 210 | 323 | ] |
| [ | 2 | 3 | 12 | 23 | 34 | 43 | 45 | 74 | 75 | 77 | 87 | 99 | 105 | 210 | 323 | 346 | 450 | 950 | ] |

*** Analysis
This is again $O(n^2)$ in time. Average is the same. In the best case though, this will be $O(n)$. Memory is $O(1)$.
Note that we can make $O(nlogn)$ comparisons instead of $O(n^2)$ by using binary search at every iteration. Swaps are
still $O(n^2)$ though, sadly.
** Merge sort
Typical divide and conquer algorithm which can be solved recursively. The beauty of recursion is that the code
is self documenting:

#+BEGIN_SRC C++ :exports both
#include <algorithm>
#include <array>
#include <iostream>

namespace my {

/// @brief Performs merge sort on array
template <size_t SIZE>
std::array<int, SIZE> mergeSort(std::array<int, SIZE>& array);

/// @brief Merge two sorted arrays
template <size_t SIZE>
std::array<int, 2 * SIZE>
mergeSortedArrays(std::array<int, SIZE>& firstSortedArray,
                  std::array<int, SIZE>& secondSortedArray);

/// @brief Prints a given array
template <size_t SIZE>
void printArrayToStdOut(const std::array<int, SIZE>& array);
}

int main() {
    using namespace my;

    std::array<int, 16> array = {3,  2,  87, 45, 43,  77,  12,  99,
                                 34, 75, 23, 74, 105, 950, 450, 346};

    printArrayToStdOut(array);

    printArrayToStdOut(mergeSort(array));

    return 0;
}

template <size_t SIZE>
std::array<int, SIZE> my::mergeSort(std::array<int, SIZE>& array) {
  if (array.size() <= 1)
        return array;

    const bool isArraySizeEven = (SIZE % 2 == 0);
    if (!isArraySizeEven) {
        std::cout << "Only even sized arrays supported for now" << std::endl;
        return array;
    }

    std::array<int, SIZE / 2> leftArray;
    leftArray.fill(-1);
    std::array<int, SIZE / 2> rightArray;
    rightArray.fill(-1);

    // std::copy(array.begin(), array.begin() + SIZE / 2, leftArray);
    // std::copy(array.begin() + SIZE / 2 + 1, array.end() + SIZE / 2,
    // rightArray);

    leftArray = mergeSort(leftArray);
    rightArray = mergeSort(rightArray);

    return mergeSortedArrays(leftArray, rightArray);
}

template <size_t SIZE>
std::array<int, 2 * SIZE>
my::mergeSortedArrays(std::array<int, SIZE>& firstSortedArray,
                      std::array<int, SIZE>& secondSortedArray) {
    // no need to do anything if arrays are empty
    if (firstSortedArray.empty() && secondSortedArray.empty())
        return firstSortedArray;
    if (firstSortedArray.empty())
        return secondSortedArray;
    if (secondSortedArray.empty())
        return firstSortedArray;

    // ensure firstSortedArray is the same size as secondSortedArray
    if (firstSortedArray.size() != secondSortedArray.size()) {
        // Until I setup asserts...
        std::cout << "Arrays must be the same size" << std::endl;
        return firstSortedArray;
    }

    size_t firstSortedArrayPtrIndex = 0;
    size_t secondSortedArrayPtrIndex = 0;
    size_t mergedArrayPtrIndex = 0;

    std::array<int, SIZE * 2> mergedArray;
    while (mergedArrayPtrIndex <= mergedArray.size()) {
        const bool allFirstSortedArrayValuesUsed =
            firstSortedArrayPtrIndex > firstSortedArray.size();
        const bool useFirstSortedArrayValue =
            !allFirstSortedArrayValuesUsed &&
            ((secondSortedArrayPtrIndex > secondSortedArray.size()) ||
             (firstSortedArray[firstSortedArrayPtrIndex] <
              secondSortedArray[secondSortedArrayPtrIndex]));
        if (useFirstSortedArrayValue) {
            mergedArray[mergedArrayPtrIndex] =
                firstSortedArray[firstSortedArrayPtrIndex];
            ++firstSortedArrayPtrIndex;
        } else {
            mergedArray[mergedArrayPtrIndex] =
                secondSortedArray[secondSortedArrayPtrIndex];
            ++secondSortedArrayPtrIndex;
        }
        ++mergedArrayPtrIndex;
    }

    return mergedArray;
}

template <size_t SIZE>
void my::printArrayToStdOut(const std::array<int, SIZE>& array) {
    std::cout << "[ ";
    for (const auto& element : array) {
        std::cout << element << " ";
    }
    std::cout << "] " << std::endl;
}

#+END_SRC
** Heap sort
** BST sort
** Counting sort
** Radix sort
